using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text;

using Microsoft.CSharp;
using Microsoft.VisualBasic;

using WrapperGenerator.ObjectModel;

namespace WrapperGenerator
{
	internal static class Generator
	{
		#region Public Methods
		public static string GenerateWrapper (WrapperClass wrapperClass, Language language)
		{
			// Namespace
			CodeNamespace _namespace = new CodeNamespace (wrapperClass.Namespace);

			// Comments
			string comment = 
				@"------------------------------------------------------------------------------"	+ Environment.NewLine +
				@" <auto-generated>"																						+ Environment.NewLine +
				@"     This code was generated by '.NET Wrapper Class Generator'"							+ Environment.NewLine +
				@"     Product Version:" + Assembly.GetExecutingAssembly ().GetName ().Version		+ Environment.NewLine + Environment.NewLine +
				@"     Changes to this file may cause incorrect behavior and will be lost if"					+ Environment.NewLine +
				@"     the code is regenerated."																			+ Environment.NewLine +
				@" </auto-generated>"																						+ Environment.NewLine +
				@" ------------------------------------------------------------------------------";
			_namespace.Comments.Add (new CodeCommentStatement (comment));

			// Class
			CodeTypeDeclaration classDeclaration = new CodeTypeDeclaration (wrapperClass.ClassName);
			classDeclaration.IsPartial = wrapperClass.Partial;
			if (wrapperClass.Sealed)
			{
				classDeclaration.TypeAttributes |= TypeAttributes.Sealed;
			}
			_namespace.Types.Add (classDeclaration);

			// Initialization
			CodeParameterDeclarationExpressionCollection initializationParameters = null;
			CodeStatementCollection initiazationStatements = null;
			if (wrapperClass.Partial)
			{
				// Initialization method
				CodeMemberMethod initializer = new CodeMemberMethod ();
				classDeclaration.Members.Add (initializer);
				initializer.Name = "InitializeWrapper";
				initializer.Attributes = MemberAttributes.Private;
				{
					comment =
						@"***************************************************************" + Environment.NewLine +
						@" This method should be called by the user-provided constructor!" + Environment.NewLine +
						@"***************************************************************";
					initializer.Comments.Add (new CodeCommentStatement (comment));
				}
				initializationParameters = initializer.Parameters;
				initiazationStatements = initializer.Statements;
			}
			else
			{
				// Constructor
				CodeConstructor constructor = new CodeConstructor ();
				classDeclaration.Members.Add (constructor);
				constructor.Attributes = MemberAttributes.Public;
				initializationParameters = constructor.Parameters;
				initiazationStatements = constructor.Statements;
			}

			// Iterate over the wrapped types
			foreach (WrappedType wrappedType in wrapperClass.WrappedTypes)
			{
				// Fields
				CodeMemberField field = new CodeMemberField (wrappedType.Type, wrappedType.FieldName);
				if (wrappedType.Acquisition != Acquisition.UserManaged)
				{
					classDeclaration.Members.Add (field);
				}
				string memberPrefix = string.Empty;
				if (wrappedType.PrefixMembers)
				{
					memberPrefix = wrappedType.FieldName;
					memberPrefix = memberPrefix.Substring (0, 1).ToUpper () + memberPrefix.Substring (1);
				}
				

				CodeFieldReferenceExpression fieldReference = new CodeFieldReferenceExpression (new CodeThisReferenceExpression (), wrappedType.FieldName);
				if (wrappedType.Acquisition == Acquisition.Construct)
				{
					// Instantiation
					CodeObjectCreateExpression instantiation = new CodeObjectCreateExpression (wrappedType.Type);
					CodeAssignStatement instanceAssignment = new CodeAssignStatement (fieldReference, instantiation);
					initiazationStatements.Add (instanceAssignment);
				}
				else if (wrappedType.Acquisition == Acquisition.Parameter)
				{
					// Pass as parameter
					initializationParameters.Add (new CodeParameterDeclarationExpression (wrappedType.Type, wrappedType.FieldName));
					initiazationStatements.Add (new CodeAssignStatement (fieldReference, new CodeVariableReferenceExpression (wrappedType.FieldName)));
				}
				else if (wrappedType.Acquisition == Acquisition.Property)
				{
					// Set as property
					CodeMemberProperty property = new CodeMemberProperty ();
					property.Attributes = MemberAttributes.Public;
					property.HasGet = property.HasSet = true;
					property.Type = new CodeTypeReference (wrappedType.Type);
					property.Name = wrappedType.Type.Name;
					property.GetStatements.Add (new CodeMethodReturnStatement (fieldReference));
					property.SetStatements.Add (new CodeAssignStatement (fieldReference, new CodeVariableReferenceExpression ("value")));
					classDeclaration.Members.Add (property);
				}

				// Methods
				foreach (WrappedMethod wrappedMethod in wrappedType.WrappedMethods)
				{
					// Method
					CodeMemberMethod method = new CodeMemberMethod ();
					classDeclaration.Members.Add (method);
					method.Name = memberPrefix + wrappedMethod.Method.Name;
					method.ReturnType = new CodeTypeReference (wrappedMethod.Method.ReturnType);

					Generator.SetMember (method, wrappedMethod);

					if (!string.IsNullOrEmpty (wrappedMethod.Interface))
					{
						method.PrivateImplementationType = new CodeTypeReference (wrappedMethod.Interface);
					}
					
					// Parameters
					List<CodeExpression> arguments = Generator.SetParameters (method, wrappedMethod.Method.GetParameters ());

					// Statement					
					CodeMethodInvokeExpression invocation = null;
					if (!wrappedMethod.Method.IsStatic)
					{
						invocation = new CodeMethodInvokeExpression (fieldReference, wrappedMethod.Method.Name, arguments.ToArray ());
					}
					else
					{
						invocation = new CodeMethodInvokeExpression (new CodeTypeReferenceExpression (wrappedType.Type), wrappedMethod.Method.Name, arguments.ToArray ());
						method.Attributes |= MemberAttributes.Static;
					}

					if (wrappedMethod.Method.ReturnType == typeof (void))
					{
						method.Statements.Add (invocation);
					}
					else
					{
						method.Statements.Add (new CodeMethodReturnStatement (invocation));
					}
				}

				// Properties
				foreach (WrappedProperty wrappedProperty in wrappedType.WrappedProperties)
				{
					// Property
					CodeMemberProperty property = new CodeMemberProperty ();
					classDeclaration.Members.Add (property);
					property.Name = memberPrefix + wrappedProperty.Property.Name;
					property.Type = new CodeTypeReference (wrappedProperty.Property.PropertyType);

					Generator.SetMember (property, wrappedProperty);

					if (!string.IsNullOrEmpty (wrappedProperty.Interface))
					{
						property.PrivateImplementationType = new CodeTypeReference (wrappedProperty.Interface);
					}

					CodePropertyReferenceExpression invocation = null;
					if (true) // TODO: check if property is static
					{
						invocation = new CodePropertyReferenceExpression (fieldReference, wrappedProperty.Property.Name);
					}
					else
					{

					}

					// Get statement
					if (wrappedProperty.Get)
					{
						property.GetStatements.Add (new CodeMethodReturnStatement (invocation));
					}

					// Set statement
					if (wrappedProperty.Set)
					{
						property.SetStatements.Add (new CodeAssignStatement (invocation, new CodeVariableReferenceExpression ("value")));
					}
				}

				// Events
				foreach (WrappedEvent wrappedEvent in wrappedType.WrappedEvents)
				{
					// Event
					MethodInfo eventDelegate = wrappedEvent.Event.EventHandlerType.GetMethod ("Invoke");

					CodeMemberEvent _event = new CodeMemberEvent ();
					classDeclaration.Members.Add (_event);
					_event.Name = memberPrefix + wrappedEvent.Event.Name;
					_event.Type = new CodeTypeReference (wrappedEvent.Event.EventHandlerType);

					Generator.SetMember (_event, wrappedEvent);

					if (!string.IsNullOrEmpty (wrappedEvent.Interface))
					{
						_event.PrivateImplementationType = new CodeTypeReference (wrappedEvent.Interface);
					}

					// Event handler/raiser
					CodeMemberMethod eventHandler = new CodeMemberMethod ();
					classDeclaration.Members.Add (eventHandler);
					eventHandler.Name = string.Format ("On{0}", _event.Name);
					eventHandler.ReturnType = new CodeTypeReference (eventDelegate.ReturnType);
					eventHandler.Attributes = MemberAttributes.Private;

					List<CodeExpression> arguments = Generator.SetParameters (eventHandler, eventDelegate.GetParameters ());

					CodeEventReferenceExpression eventReference = new CodeEventReferenceExpression (new CodeThisReferenceExpression (), _event.Name);
					CodeConditionStatement conditional = new CodeConditionStatement ();
					eventHandler.Statements.Add (conditional);
					conditional.Condition = new CodeBinaryOperatorExpression (eventReference, CodeBinaryOperatorType.IdentityInequality, new CodePrimitiveExpression (null));

					CodeDelegateInvokeExpression eventInvocation = new CodeDelegateInvokeExpression (eventReference, arguments.ToArray ());
					if (eventDelegate.ReturnType == typeof (void))
					{
						conditional.TrueStatements.Add (eventInvocation);
					}
					else
					{
						conditional.TrueStatements.Add (new CodeMethodReturnStatement (eventInvocation));
					}
			
					// Event registration
					CodeEventReferenceExpression wrappedEventReference = new CodeEventReferenceExpression (fieldReference, wrappedEvent.Event.Name);
					CodeMethodReferenceExpression eventRaiserReference = new CodeMethodReferenceExpression (new CodeThisReferenceExpression (), eventHandler.Name);
					CodeAttachEventStatement eventRegistration = new CodeAttachEventStatement (wrappedEventReference, eventRaiserReference);
					initiazationStatements.Add (eventRegistration);
				}
			}

			// Generate the code
			StringWriter stringWriter = new StringWriter ();
			CodeDomProvider codeProvider = null;
			if (language == Language.CSharp)
			{
				codeProvider = new CSharpCodeProvider ();
			}
			else if (language == Language.VBNet)
			{
				codeProvider = new VBCodeProvider ();
			}
			else
			{
				throw new ArgumentException ("Specified language is not supported: " + language);
			}
			CodeGeneratorOptions options = new CodeGeneratorOptions ();
			options.BracingStyle = "C";
			codeProvider.GenerateCodeFromNamespace (_namespace, stringWriter, options);
			return stringWriter.ToString ();
		}
		#endregion

		#region Private Methods
		private static void SetMember (CodeTypeMember member, WrappedMember wrappedMember)
		{
			if (wrappedMember.Accessibility == Accessibility.Public)
			{
				member.Attributes = MemberAttributes.Public;
			}
			else if (wrappedMember.Accessibility == Accessibility.Protected)
			{
				member.Attributes = MemberAttributes.Family;
			}
			else if (wrappedMember.Accessibility == Accessibility.Private)
			{
				member.Attributes = MemberAttributes.Private;
			}

			if (!wrappedMember.Virtual)
			{
				member.Attributes |= MemberAttributes.Final;
			}
		}

		private static List<CodeExpression> SetParameters (CodeMemberMethod method, ParameterInfo[] parameterInfos)
		{
			List<CodeExpression> arguments = new List<CodeExpression> ();
			foreach (ParameterInfo parameterInfo in parameterInfos)
			{
				// Parameter
				CodeParameterDeclarationExpression parameter = new CodeParameterDeclarationExpression ();
				parameter.Type = new CodeTypeReference (parameterInfo.ParameterType.Name.TrimEnd ('&'));
				parameter.Name = parameterInfo.Name;

				// Argument
				CodeVariableReferenceExpression argument = new CodeVariableReferenceExpression (parameter.Name);

				if (parameterInfo.ParameterType.Name.EndsWith ("&"))
				{
					if (parameterInfo.IsOut)
					{
						parameter.Direction = FieldDirection.Out;
						arguments.Add (new CodeDirectionExpression (FieldDirection.Out, argument));
					}
					else
					{
						parameter.Direction = FieldDirection.Ref;
						arguments.Add (new CodeDirectionExpression (FieldDirection.Ref, argument));
					}
				}
				else
				{
					arguments.Add (argument);
				}
				method.Parameters.Add (parameter);
			}
			return arguments;
		}
		#endregion
	}
}
